/* tslint:disable */
/* eslint-disable */
/**
 * The Sign Serverâ„¢
 * Sign Server API Documentation
 *
 * The version of the OpenAPI document: dev
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ApiRoutes = {
    ApiLive: 'api-live',
    InfoByUser: 'info-by-user'
} as const;

export type ApiRoutes = typeof ApiRoutes[keyof typeof ApiRoutes];


/**
 * 
 * @export
 * @interface IAlert
 */
export interface IAlert {
    /**
     * 
     * @type {string}
     * @memberof IAlert
     */
    'unique_id': string;
    /**
     * 
     * @type {number}
     * @memberof IAlert
     */
    'account_id': number;
    /**
     * 
     * @type {number}
     * @memberof IAlert
     */
    'alert_creator_id': number;
    /**
     * 
     * @type {number}
     * @memberof IAlert
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof IAlert
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof IAlert
     */
    'alert_creator_username': string;
}
/**
 * 
 * @export
 * @interface IAlertConfigBase
 */
export interface IAlertConfigBase {
    /**
     * 
     * @type {string}
     * @memberof IAlertConfigBase
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface IAlertTarget
 */
export interface IAlertTarget {
    /**
     * 
     * @type {string}
     * @memberof IAlertTarget
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof IAlertTarget
     */
    'alert_id': number;
    /**
     * 
     * @type {number}
     * @memberof IAlertTarget
     */
    'alert_creator_id': number;
    /**
     * 
     * @type {number}
     * @memberof IAlertTarget
     */
    'id': number;
    /**
     * 
     * @type {IAlertTargetStatus}
     * @memberof IAlertTarget
     */
    'last_status': IAlertTargetStatus;
    /**
     * 
     * @type {string}
     * @memberof IAlertTarget
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof IAlertTarget
     */
    'updated_at': string;
    /**
     * 
     * @type {IAlertTargetFormat}
     * @memberof IAlertTarget
     */
    'format': IAlertTargetFormat;
}


/**
 * 
 * @export
 * @interface IAlertTargetConfigBase
 */
export interface IAlertTargetConfigBase {
    /**
     * 
     * @type {string}
     * @memberof IAlertTargetConfigBase
     */
    'url': string;
}
/**
 * 
 * @export
 * @enum {number}
 */

export const IAlertTargetFormat = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type IAlertTargetFormat = typeof IAlertTargetFormat[keyof typeof IAlertTargetFormat];


/**
 * 
 * @export
 * @enum {number}
 */

export const IAlertTargetStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_4: 4
} as const;

export type IAlertTargetStatus = typeof IAlertTargetStatus[keyof typeof IAlertTargetStatus];


/**
 * 
 * @export
 * @interface IApiKey
 */
export interface IApiKey {
    /**
     * 
     * @type {string}
     * @memberof IApiKey
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IApiKey
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof IApiKey
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof IApiKey
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof IApiKey
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof IApiKey
     */
    'account_id': number;
}
/**
 * 
 * @export
 * @interface IApiKeyConfig
 */
export interface IApiKeyConfig {
    /**
     * 
     * @type {string}
     * @memberof IApiKeyConfig
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IApiKeyConfig
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface IApiKeyConfigBase
 */
export interface IApiKeyConfigBase {
    /**
     * 
     * @type {string}
     * @memberof IApiKeyConfigBase
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ICountSignUsage
 */
export interface ICountSignUsage {
    /**
     * 
     * @type {number}
     * @memberof ICountSignUsage
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ICountSignUsage
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof ICountSignUsage
     */
    'pages'?: number;
}
/**
 * 
 * @export
 * @interface ICreateAlertResponse
 */
export interface ICreateAlertResponse {
    /**
     * 
     * @type {number}
     * @memberof ICreateAlertResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ICreateAlertResponse
     */
    'message'?: string;
    /**
     * 
     * @type {IAlert}
     * @memberof ICreateAlertResponse
     */
    'alert'?: IAlert;
}
/**
 * 
 * @export
 * @interface ICreateAlertTargetResponse
 */
export interface ICreateAlertTargetResponse {
    /**
     * 
     * @type {number}
     * @memberof ICreateAlertTargetResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ICreateAlertTargetResponse
     */
    'message'?: string;
    /**
     * 
     * @type {IAlertTarget}
     * @memberof ICreateAlertTargetResponse
     */
    'target'?: IAlertTarget;
}
/**
 * 
 * @export
 * @interface ICreateJWTResponse
 */
export interface ICreateJWTResponse {
    /**
     * 
     * @type {number}
     * @memberof ICreateJWTResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ICreateJWTResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ICreateJWTResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface ICreateKeyResponse
 */
export interface ICreateKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof ICreateKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ICreateKeyResponse
     */
    'message'?: string;
    /**
     * 
     * @type {IApiKey}
     * @memberof ICreateKeyResponse
     */
    'key'?: IApiKey;
}
/**
 * 
 * @export
 * @interface IDeleteAlertTargetResponse
 */
export interface IDeleteAlertTargetResponse {
    /**
     * 
     * @type {number}
     * @memberof IDeleteAlertTargetResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IDeleteAlertTargetResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface IDeleteKeyResponse
 */
export interface IDeleteKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof IDeleteKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IDeleteKeyResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface IGetRateLimits
 */
export interface IGetRateLimits {
    /**
     * 
     * @type {number}
     * @memberof IGetRateLimits
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IGetRateLimits
     */
    'message'?: string;
    /**
     * 
     * @type {IRateLimitInfo}
     * @memberof IGetRateLimits
     */
    'day'?: IRateLimitInfo;
    /**
     * 
     * @type {IRateLimitInfo}
     * @memberof IGetRateLimits
     */
    'hour'?: IRateLimitInfo;
    /**
     * 
     * @type {IRateLimitInfo}
     * @memberof IGetRateLimits
     */
    'minute'?: IRateLimitInfo;
}
/**
 * 
 * @export
 * @interface IGetSignUsageResponse
 */
export interface IGetSignUsageResponse {
    /**
     * 
     * @type {number}
     * @memberof IGetSignUsageResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IGetSignUsageResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ISignLogPublic>}
     * @memberof IGetSignUsageResponse
     */
    'usage'?: Array<ISignLogPublic>;
}
/**
 * 
 * @export
 * @interface IGetSignWebcastUrlResponse
 */
export interface IGetSignWebcastUrlResponse {
    /**
     * 
     * @type {number}
     * @memberof IGetSignWebcastUrlResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'signedUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'msToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'browserVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'browserName'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    '_signature'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'X-Bogus'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGetSignWebcastUrlResponse
     */
    'User-Agent'?: string;
}
/**
 * 
 * @export
 * @interface IHostsResponse
 */
export interface IHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof IHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IHostsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IHostsResponse
     */
    'hosts'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IJSONResponse
 */
export interface IJSONResponse {
    /**
     * 
     * @type {number}
     * @memberof IJSONResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IJSONResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface IListAlertTargetsResponse
 */
export interface IListAlertTargetsResponse {
    /**
     * 
     * @type {number}
     * @memberof IListAlertTargetsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IListAlertTargetsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<IAlertTarget>}
     * @memberof IListAlertTargetsResponse
     */
    'targets'?: Array<IAlertTarget>;
}
/**
 * 
 * @export
 * @interface IListAlertsResponse
 */
export interface IListAlertsResponse {
    /**
     * 
     * @type {number}
     * @memberof IListAlertsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IListAlertsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<IAlert>}
     * @memberof IListAlertsResponse
     */
    'alerts'?: Array<IAlert>;
}
/**
 * 
 * @export
 * @interface IListKeysResponse
 */
export interface IListKeysResponse {
    /**
     * 
     * @type {number}
     * @memberof IListKeysResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IListKeysResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<IApiKey>}
     * @memberof IListKeysResponse
     */
    'keys'?: Array<IApiKey>;
}
/**
 * 
 * @export
 * @interface IPipResponse
 */
export interface IPipResponse {
    /**
     * 
     * @type {number}
     * @memberof IPipResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IPipResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof IPipResponse
     */
    'image_url': string;
    /**
     * 
     * @type {string}
     * @memberof IPipResponse
     */
    'label': string;
    /**
     * 
     * @type {number}
     * @memberof IPipResponse
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof IPipResponse
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface IRateLimitInfo
 */
export interface IRateLimitInfo {
    /**
     * 
     * @type {number}
     * @memberof IRateLimitInfo
     */
    'max': number;
    /**
     * 
     * @type {number}
     * @memberof IRateLimitInfo
     */
    'remaining': number;
    /**
     * 
     * @type {string}
     * @memberof IRateLimitInfo
     */
    'reset_at': string | null;
}
/**
 * 
 * @export
 * @interface IRetrieveAgentHostsResponse
 */
export interface IRetrieveAgentHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof IRetrieveAgentHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IRetrieveAgentHostsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {IRetrieveAgentHostsResponseAgents}
     * @memberof IRetrieveAgentHostsResponse
     */
    'agents': IRetrieveAgentHostsResponseAgents;
}
/**
 * 
 * @export
 * @interface IRetrieveAgentHostsResponseAgents
 */
export interface IRetrieveAgentHostsResponseAgents {
    /**
     * 
     * @type {Array<string>}
     * @memberof IRetrieveAgentHostsResponseAgents
     */
    'enterprise': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IRetrieveAgentHostsResponseAgents
     */
    'tiktory': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IRetrieveAgentHostsResponseAgents
     */
    'public': Array<string>;
}
/**
 * 
 * @export
 * @interface IRetrieveAggregateUsageResponse
 */
export interface IRetrieveAggregateUsageResponse {
    /**
     * 
     * @type {number}
     * @memberof IRetrieveAggregateUsageResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IRetrieveAggregateUsageResponse
     */
    'message'?: string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: object; }}
     * @memberof IRetrieveAggregateUsageResponse
     */
    'usage'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface IRetrieveAlertResponse
 */
export interface IRetrieveAlertResponse {
    /**
     * 
     * @type {number}
     * @memberof IRetrieveAlertResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IRetrieveAlertResponse
     */
    'message'?: string;
    /**
     * 
     * @type {IAlert}
     * @memberof IRetrieveAlertResponse
     */
    'alert'?: IAlert;
    /**
     * 
     * @type {IRetrieveAlertResponseCreator}
     * @memberof IRetrieveAlertResponse
     */
    'creator'?: IRetrieveAlertResponseCreator;
}
/**
 * 
 * @export
 * @interface IRetrieveAlertResponseCreator
 */
export interface IRetrieveAlertResponseCreator {
    /**
     * 
     * @type {string}
     * @memberof IRetrieveAlertResponseCreator
     */
    'room_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof IRetrieveAlertResponseCreator
     */
    'state_label': string;
    /**
     * 
     * @type {number}
     * @memberof IRetrieveAlertResponseCreator
     */
    'state': number;
    /**
     * 
     * @type {string}
     * @memberof IRetrieveAlertResponseCreator
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface IRetrieveKeyResponse
 */
export interface IRetrieveKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof IRetrieveKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IRetrieveKeyResponse
     */
    'message'?: string;
    /**
     * 
     * @type {IApiKey}
     * @memberof IRetrieveKeyResponse
     */
    'key'?: IApiKey;
}
/**
 * 
 * @export
 * @interface ISignLogPublic
 */
export interface ISignLogPublic {
    /**
     * 
     * @type {number}
     * @memberof ISignLogPublic
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ISignLogPublic
     */
    'ts': string;
    /**
     * 
     * @type {number}
     * @memberof ISignLogPublic
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ISignLogPublic
     */
    'client': string;
    /**
     * 
     * @type {string}
     * @memberof ISignLogPublic
     */
    'ip': string;
    /**
     * 
     * @type {number}
     * @memberof ISignLogPublic
     */
    'api_key_id': number;
    /**
     * 
     * @type {string}
     * @memberof ISignLogPublic
     */
    'user_agent': string;
    /**
     * 
     * @type {string}
     * @memberof ISignLogPublic
     */
    'agent_id': string;
}
/**
 * 
 * @export
 * @interface ISignTikTokUrlBody
 */
export interface ISignTikTokUrlBody {
    /**
     * 
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'userAgent'?: string;
    /**
     * 
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'method'?: ISignTikTokUrlBodyMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'ttTargetIdc'?: string;
    /**
     * 
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'payload'?: string;
    /**
     * 
     * @type {string}
     * @memberof ISignTikTokUrlBody
     */
    'type'?: ISignTikTokUrlBodyTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ISignTikTokUrlBody
     */
    'includeBrowserParams'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ISignTikTokUrlBody
     */
    'includeVerifyFp'?: boolean;
}

export const ISignTikTokUrlBodyMethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Options: 'OPTIONS',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD'
} as const;

export type ISignTikTokUrlBodyMethodEnum = typeof ISignTikTokUrlBodyMethodEnum[keyof typeof ISignTikTokUrlBodyMethodEnum];
export const ISignTikTokUrlBodyTypeEnum = {
    Fetch: 'fetch',
    Xhr: 'xhr'
} as const;

export type ISignTikTokUrlBodyTypeEnum = typeof ISignTikTokUrlBodyTypeEnum[keyof typeof ISignTikTokUrlBodyTypeEnum];

/**
 * 
 * @export
 * @interface ISignTikTokUrlResponse
 */
export interface ISignTikTokUrlResponse {
    /**
     * 
     * @type {number}
     * @memberof ISignTikTokUrlResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ISignTikTokUrlResponse
     */
    'message'?: string;
    /**
     * 
     * @type {PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray}
     * @memberof ISignTikTokUrlResponse
     */
    'response'?: PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray;
}
/**
 * 
 * @export
 * @interface ITestAlertTargetResponse
 */
export interface ITestAlertTargetResponse {
    /**
     * 
     * @type {number}
     * @memberof ITestAlertTargetResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ITestAlertTargetResponse
     */
    'message'?: string;
    /**
     * 
     * @type {IAlertTargetStatus}
     * @memberof ITestAlertTargetResponse
     */
    'status'?: IAlertTargetStatus;
    /**
     * 
     * @type {string}
     * @memberof ITestAlertTargetResponse
     */
    'statusLabel'?: string;
}


/**
 * 
 * @export
 * @interface IUpdateKeyResponse
 */
export interface IUpdateKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof IUpdateKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IUpdateKeyResponse
     */
    'message'?: string;
    /**
     * 
     * @type {IApiKeyConfig}
     * @memberof IUpdateKeyResponse
     */
    'config'?: IApiKeyConfig;
}
/**
 * 
 * @export
 * @interface IWebcastRoomChatPayload
 */
export interface IWebcastRoomChatPayload {
    /**
     * 
     * @type {string}
     * @memberof IWebcastRoomChatPayload
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof IWebcastRoomChatPayload
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof IWebcastRoomChatPayload
     */
    'ttTargetIdc': string;
    /**
     * 
     * @type {string}
     * @memberof IWebcastRoomChatPayload
     */
    'roomId': string;
}
/**
 * 
 * @export
 * @interface IWebcastRoomChatRouteResponse
 */
export interface IWebcastRoomChatRouteResponse {
    /**
     * 
     * @type {number}
     * @memberof IWebcastRoomChatRouteResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IWebcastRoomChatRouteResponse
     */
    'message'?: string;
    /**
     * 
     * @type {any}
     * @memberof IWebcastRoomChatRouteResponse
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface IWebcastRoomIdRouteResponse
 */
export interface IWebcastRoomIdRouteResponse {
    /**
     * 
     * @type {number}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'room_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'ok': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'routes_attempted': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof IWebcastRoomIdRouteResponse
     */
    'is_live'?: boolean;
}
/**
 * 
 * @export
 * @interface IWebcastRoomInfoRouteResponse
 */
export interface IWebcastRoomInfoRouteResponse {
    /**
     * 
     * @type {number}
     * @memberof IWebcastRoomInfoRouteResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof IWebcastRoomInfoRouteResponse
     */
    'message'?: string;
    /**
     * 
     * @type {TikTokLiveUser}
     * @memberof IWebcastRoomInfoRouteResponse
     */
    'data'?: TikTokLiveUser;
    /**
     * 
     * @type {boolean}
     * @memberof IWebcastRoomInfoRouteResponse
     */
    'ok': boolean;
    /**
     * 
     * @type {Array<ApiRoutes>}
     * @memberof IWebcastRoomInfoRouteResponse
     */
    'routes_attempted': Array<ApiRoutes>;
}
/**
 * 
 * @export
 * @interface JWTCreateConfig
 */
export interface JWTCreateConfig {
    /**
     * 
     * @type {JWTCreateConfigLimits}
     * @memberof JWTCreateConfig
     */
    'limits': JWTCreateConfigLimits;
    /**
     * 
     * @type {number}
     * @memberof JWTCreateConfig
     */
    'expireAfter': number;
}
/**
 * 
 * @export
 * @interface JWTCreateConfigLimits
 */
export interface JWTCreateConfigLimits {
    /**
     * 
     * @type {number}
     * @memberof JWTCreateConfigLimits
     */
    'minute': number;
    /**
     * 
     * @type {number}
     * @memberof JWTCreateConfigLimits
     */
    'hour': number;
    /**
     * 
     * @type {number}
     * @memberof JWTCreateConfigLimits
     */
    'day': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LiveClient = {
    TtliveJava: 'ttlive-java',
    TtliveNode: 'ttlive-node',
    TtlivePython: 'ttlive-python',
    TtliveRust: 'ttlive-rust',
    TtliveGo: 'ttlive-go',
    TtliveOther: 'ttlive-other'
} as const;

export type LiveClient = typeof LiveClient[keyof typeof LiveClient];


/**
 * 
 * @export
 * @enum {number}
 */

export const LogRequestMethod = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type LogRequestMethod = typeof LogRequestMethod[keyof typeof LogRequestMethod];


/**
 * Make all properties in T optional
 * @export
 * @interface PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
 */
export interface PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber {
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'sec_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'numeric_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'signature'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'is_verified'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'following'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'followers'?: number;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
 */
export interface PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray {
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'signedUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'userAgent'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'browserName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'browserVersion'?: string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'tokens'?: { [key: string]: string; };
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'requestHeaders'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<object>}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray
     */
    'cookies'?: Array<object>;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
 */
export interface PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString {
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'status'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'is_live'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'cover_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'start_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'current_viewers'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'total_viewers'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'hls_pull_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'hls_pull_url_ld'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'flv_pull_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString
     */
    'flv_pull_url_ld'?: string;
}
/**
 * 
 * @export
 * @interface Pips200Response
 */
export interface Pips200Response {
    /**
     * 
     * @type {number}
     * @memberof Pips200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof Pips200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pips200Response
     */
    'image_url': string;
    /**
     * 
     * @type {string}
     * @memberof Pips200Response
     */
    'label': string;
    /**
     * 
     * @type {number}
     * @memberof Pips200Response
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof Pips200Response
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface SignWebcastUrl200Response
 */
export interface SignWebcastUrl200Response {
    /**
     * 
     * @type {number}
     * @memberof SignWebcastUrl200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof SignWebcastUrl200Response
     */
    'message'?: string;
    /**
     * 
     * @type {PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray}
     * @memberof SignWebcastUrl200Response
     */
    'response'?: PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringAnyArray;
}
/**
 * 
 * @export
 * @interface TikTokLiveUser
 */
export interface TikTokLiveUser {
    /**
     * Construct a type with a set of properties K of type T
     * @type {object}
     * @memberof TikTokLiveUser
     */
    'raw': object;
    /**
     * 
     * @type {PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString}
     * @memberof TikTokLiveUser
     */
    'room_info'?: PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringHlsPullUrlLdStringFlvPullUrlStringFlvPullUrlLdString;
    /**
     * 
     * @type {TikTokLiveUserUser}
     * @memberof TikTokLiveUser
     */
    'user'?: TikTokLiveUserUser;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUser
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface TikTokLiveUserUser
 */
export interface TikTokLiveUserUser {
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'sec_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'numeric_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'signature'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TikTokLiveUserUser
     */
    'is_verified'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TikTokLiveUserUser
     */
    'following'?: number;
    /**
     * 
     * @type {number}
     * @memberof TikTokLiveUserUser
     */
    'followers'?: number;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'unique_id': string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage: async (accountId: number, from: string, to: string, apiKeyId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('countSignUsage', 'accountId', accountId)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('countSignUsage', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('countSignUsage', 'to', to)
            const localVarPath = `/accounts/{account_id}/usage/sign_usage/page_count`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (apiKeyId !== undefined) {
                localVarQueryParameter['api_key_id'] = apiKeyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage: async (accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getSignUsage', 'accountId', accountId)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getSignUsage', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getSignUsage', 'to', to)
            const localVarPath = `/accounts/{account_id}/usage/sign_usage`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (apiKeyId !== undefined) {
                localVarQueryParameter['api_key_id'] = apiKeyId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage: async (accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('retrieveAggregateUsage', 'accountId', accountId)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('retrieveAggregateUsage', 'period', period)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('retrieveAggregateUsage', 'value', value)
            const localVarPath = `/accounts/{account_id}/usage/sign_usage/aggregate`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICountSignUsage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countSignUsage(accountId, from, to, apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.countSignUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IGetSignUsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignUsage(accountId, from, to, apiKeyId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getSignUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IRetrieveAggregateUsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAggregateUsage(accountId, period, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.retrieveAggregateUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig): AxiosPromise<ICountSignUsage> {
            return localVarFp.countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<IGetSignUsageResponse> {
            return localVarFp.getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig): AxiosPromise<IRetrieveAggregateUsageResponse> {
            return localVarFp.retrieveAggregateUsage(accountId, period, value, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).retrieveAggregateUsage(accountId, period, value, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RetrieveAggregateUsagePeriodEnum = {
    Hour: 'hour',
    Day: 'day'
} as const;
export type RetrieveAggregateUsagePeriodEnum = typeof RetrieveAggregateUsagePeriodEnum[keyof typeof RetrieveAggregateUsagePeriodEnum];


/**
 * AlertTargetsApi - axios parameter creator
 * @export
 */
export const AlertTargetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget: async (accountId: number, alertId: number, iAlertTargetConfigBase: IAlertTargetConfigBase, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createAlertTarget', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('createAlertTarget', 'alertId', alertId)
            // verify required parameter 'iAlertTargetConfigBase' is not null or undefined
            assertParamExists('createAlertTarget', 'iAlertTargetConfigBase', iAlertTargetConfigBase)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iAlertTargetConfigBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget: async (accountId: number, alertId: number, targetId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAlertTarget', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('deleteAlertTarget', 'alertId', alertId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('deleteAlertTarget', 'targetId', targetId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets: async (accountId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAlertTargets', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('listAlertTargets', 'alertId', alertId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget: async (accountId: number, alertId: number, targetId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('testAlertTarget', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('testAlertTarget', 'alertId', alertId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('testAlertTarget', 'targetId', targetId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/test`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertTargetsApi - functional programming interface
 * @export
 */
export const AlertTargetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertTargetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlertTarget(accountId: number, alertId: number, iAlertTargetConfigBase: IAlertTargetConfigBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICreateAlertTargetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertTarget(accountId, alertId, iAlertTargetConfigBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertTargetsApi.createAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IDeleteAlertTargetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertTargetsApi.deleteAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IListAlertTargetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertTargets(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertTargetsApi.listAlertTargets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ITestAlertTargetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertTargetsApi.testAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlertTargetsApi - factory interface
 * @export
 */
export const AlertTargetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertTargetsApiFp(configuration)
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget(accountId: number, alertId: number, iAlertTargetConfigBase: IAlertTargetConfigBase, options?: RawAxiosRequestConfig): AxiosPromise<ICreateAlertTargetResponse> {
            return localVarFp.createAlertTarget(accountId, alertId, iAlertTargetConfigBase, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): AxiosPromise<IDeleteAlertTargetResponse> {
            return localVarFp.deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<IListAlertTargetsResponse> {
            return localVarFp.listAlertTargets(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): AxiosPromise<ITestAlertTargetResponse> {
            return localVarFp.testAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertTargetsApi - object-oriented interface
 * @export
 * @class AlertTargetsApi
 * @extends {BaseAPI}
 */
export class AlertTargetsApi extends BaseAPI {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {IAlertTargetConfigBase} iAlertTargetConfigBase Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    public createAlertTarget(accountId: number, alertId: number, iAlertTargetConfigBase: IAlertTargetConfigBase, options?: RawAxiosRequestConfig) {
        return AlertTargetsApiFp(this.configuration).createAlertTarget(accountId, alertId, iAlertTargetConfigBase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    public deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig) {
        return AlertTargetsApiFp(this.configuration).deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    public listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig) {
        return AlertTargetsApiFp(this.configuration).listAlertTargets(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    public testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig) {
        return AlertTargetsApiFp(this.configuration).testAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a creator alert. These alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert: async (accountId: number, iAlertConfigBase: IAlertConfigBase, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createAlert', 'accountId', accountId)
            // verify required parameter 'iAlertConfigBase' is not null or undefined
            assertParamExists('createAlert', 'iAlertConfigBase', iAlertConfigBase)
            const localVarPath = `/accounts/{account_id}/alerts/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iAlertConfigBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAlerts', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/alerts/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert: async (accountId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('retrieveAlert', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('retrieveAlert', 'alertId', alertId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a creator alert. These alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlert(accountId: number, iAlertConfigBase: IAlertConfigBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICreateAlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlert(accountId, iAlertConfigBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.createAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlerts(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IListAlertsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlerts(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.listAlerts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IRetrieveAlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAlert(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.retrieveAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * Create a creator alert. These alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(accountId: number, iAlertConfigBase: IAlertConfigBase, options?: RawAxiosRequestConfig): AxiosPromise<ICreateAlertResponse> {
            return localVarFp.createAlert(accountId, iAlertConfigBase, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<IListAlertsResponse> {
            return localVarFp.listAlerts(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<IRetrieveAlertResponse> {
            return localVarFp.retrieveAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     * Create a creator alert. These alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {IAlertConfigBase} iAlertConfigBase Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public createAlert(accountId: number, iAlertConfigBase: IAlertConfigBase, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).createAlert(accountId, iAlertConfigBase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public listAlerts(accountId: number, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).listAlerts(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).retrieveAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch a webcast URL for a given room ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve stats as an SVG
         * @param {LogRequestMethod} statName Name of the stat to retrieve
         * @param {string} [labelColour] Specify label colour in SVG
         * @param {string} [valueColour] Specify value colour in SVG
         * @param {number} [hours] The number of hours to retrieve the stat for
         * @param {LiveClient} [client] The client to filter for
         * @param {boolean} [json] Add the ability to retrieve the pip as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pips: async (statName: LogRequestMethod, labelColour?: string, valueColour?: string, hours?: number, client?: LiveClient, json?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'statName' is not null or undefined
            assertParamExists('pips', 'statName', statName)
            const localVarPath = `/analytics/pips/{statName}`
                .replace(`{${"statName"}}`, encodeURIComponent(String(statName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (labelColour !== undefined) {
                localVarQueryParameter['labelColour'] = labelColour;
            }

            if (valueColour !== undefined) {
                localVarQueryParameter['valueColour'] = valueColour;
            }

            if (hours !== undefined) {
                localVarQueryParameter['hours'] = hours;
            }

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }

            if (json !== undefined) {
                localVarQueryParameter['json'] = json;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch a webcast URL for a given room ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAgents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IRetrieveAgentHostsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAgents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.fetchAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHosts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IHostsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHosts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getHosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve stats as an SVG
         * @param {LogRequestMethod} statName Name of the stat to retrieve
         * @param {string} [labelColour] Specify label colour in SVG
         * @param {string} [valueColour] Specify value colour in SVG
         * @param {number} [hours] The number of hours to retrieve the stat for
         * @param {LiveClient} [client] The client to filter for
         * @param {boolean} [json] Add the ability to retrieve the pip as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pips(statName: LogRequestMethod, labelColour?: string, valueColour?: string, hours?: number, client?: LiveClient, json?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pips200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pips(statName, labelColour, valueColour, hours, client, json, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.pips']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * Fetch a webcast URL for a given room ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents(options?: RawAxiosRequestConfig): AxiosPromise<IRetrieveAgentHostsResponse> {
            return localVarFp.fetchAgents(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts(options?: RawAxiosRequestConfig): AxiosPromise<IHostsResponse> {
            return localVarFp.getHosts(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve stats as an SVG
         * @param {LogRequestMethod} statName Name of the stat to retrieve
         * @param {string} [labelColour] Specify label colour in SVG
         * @param {string} [valueColour] Specify value colour in SVG
         * @param {number} [hours] The number of hours to retrieve the stat for
         * @param {LiveClient} [client] The client to filter for
         * @param {boolean} [json] Add the ability to retrieve the pip as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pips(statName: LogRequestMethod, labelColour?: string, valueColour?: string, hours?: number, client?: LiveClient, json?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Pips200Response> {
            return localVarFp.pips(statName, labelColour, valueColour, hours, client, json, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Fetch a webcast URL for a given room ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public fetchAgents(options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).fetchAgents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getHosts(options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getHosts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve stats as an SVG
     * @param {LogRequestMethod} statName Name of the stat to retrieve
     * @param {string} [labelColour] Specify label colour in SVG
     * @param {string} [valueColour] Specify value colour in SVG
     * @param {number} [hours] The number of hours to retrieve the stat for
     * @param {LiveClient} [client] The client to filter for
     * @param {boolean} [json] Add the ability to retrieve the pip as JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public pips(statName: LogRequestMethod, labelColour?: string, valueColour?: string, hours?: number, client?: LiveClient, json?: boolean, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).pips(statName, labelColour, valueColour, hours, client, json, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT: async (accountId: number, jWTCreateConfig: JWTCreateConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createJWT', 'accountId', accountId)
            // verify required parameter 'jWTCreateConfig' is not null or undefined
            assertParamExists('createJWT', 'jWTCreateConfig', jWTCreateConfig)
            const localVarPath = `/accounts/{account_id}/jwt/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jWTCreateConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (accountId: number, iApiKeyConfigBase: IApiKeyConfigBase, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createKey', 'accountId', accountId)
            // verify required parameter 'iApiKeyConfigBase' is not null or undefined
            assertParamExists('createKey', 'iApiKeyConfigBase', iApiKeyConfigBase)
            const localVarPath = `/accounts/{account_id}/api_keys/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iApiKeyConfigBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteKey', 'accountId', accountId)
            // verify required parameter 'deleteBy' is not null or undefined
            assertParamExists('deleteKey', 'deleteBy', deleteBy)
            // verify required parameter 'deleteParam' is not null or undefined
            assertParamExists('deleteKey', 'deleteParam', deleteParam)
            const localVarPath = `/accounts/{account_id}/api_keys/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (deleteBy !== undefined) {
                localVarQueryParameter['delete_by'] = deleteBy;
            }

            if (deleteParam !== undefined) {
                localVarQueryParameter['delete_param'] = deleteParam;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey: async (accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getKey', 'accountId', accountId)
            // verify required parameter 'retrieveParam' is not null or undefined
            assertParamExists('getKey', 'retrieveParam', retrieveParam)
            const localVarPath = `/accounts/{account_id}/api_keys/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (retrieveBy !== undefined) {
                localVarQueryParameter['retrieve_by'] = retrieveBy;
            }

            if (retrieveParam !== undefined) {
                localVarQueryParameter['retrieve_param'] = retrieveParam;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listKeys', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/api_keys/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey: async (accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, iApiKeyConfigBase: IApiKeyConfigBase, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateKey', 'accountId', accountId)
            // verify required parameter 'updateBy' is not null or undefined
            assertParamExists('updateKey', 'updateBy', updateBy)
            // verify required parameter 'updateParam' is not null or undefined
            assertParamExists('updateKey', 'updateParam', updateParam)
            // verify required parameter 'iApiKeyConfigBase' is not null or undefined
            assertParamExists('updateKey', 'iApiKeyConfigBase', iApiKeyConfigBase)
            const localVarPath = `/accounts/{account_id}/api_keys/update`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (updateBy !== undefined) {
                localVarQueryParameter['update_by'] = updateBy;
            }

            if (updateParam !== undefined) {
                localVarQueryParameter['update_param'] = updateParam;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iApiKeyConfigBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICreateJWTResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJWT(accountId, jWTCreateConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.createJWT']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(accountId: number, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ICreateKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(accountId, iApiKeyConfigBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.createKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IDeleteKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(accountId, deleteBy, deleteParam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.deleteKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IRetrieveKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(accountId, retrieveParam, retrieveBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeys(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IListKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeys(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.listKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IUpdateKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKey(accountId, updateBy, updateParam, iApiKeyConfigBase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.updateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): AxiosPromise<ICreateJWTResponse> {
            return localVarFp.createJWT(accountId, jWTCreateConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(accountId: number, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig): AxiosPromise<ICreateKeyResponse> {
            return localVarFp.createKey(accountId, iApiKeyConfigBase, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): AxiosPromise<IDeleteKeyResponse> {
            return localVarFp.deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): AxiosPromise<IRetrieveKeyResponse> {
            return localVarFp.getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<IListKeysResponse> {
            return localVarFp.listKeys(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig): AxiosPromise<IUpdateKeyResponse> {
            return localVarFp.updateKey(accountId, updateBy, updateParam, iApiKeyConfigBase, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).createJWT(accountId, jWTCreateConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public createKey(accountId: number, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).createKey(accountId, iApiKeyConfigBase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public listKeys(accountId: number, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).listKeys(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {IApiKeyConfigBase} iApiKeyConfigBase The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, iApiKeyConfigBase: IApiKeyConfigBase, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).updateKey(accountId, updateBy, updateParam, iApiKeyConfigBase, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteKeyDeleteByEnum = {
    Value: 'value',
    Name: 'name',
    Id: 'id'
} as const;
export type DeleteKeyDeleteByEnum = typeof DeleteKeyDeleteByEnum[keyof typeof DeleteKeyDeleteByEnum];
/**
 * @export
 */
export const GetKeyRetrieveByEnum = {
    Value: 'value',
    Name: 'name',
    Id: 'id'
} as const;
export type GetKeyRetrieveByEnum = typeof GetKeyRetrieveByEnum[keyof typeof GetKeyRetrieveByEnum];
/**
 * @export
 */
export const UpdateKeyUpdateByEnum = {
    Value: 'value',
    Name: 'name',
    Id: 'id'
} as const;
export type UpdateKeyUpdateByEnum = typeof UpdateKeyUpdateByEnum[keyof typeof UpdateKeyUpdateByEnum];


/**
 * TikTokApi - axios parameter creator
 * @export
 */
export const TikTokApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sign a non-LIVE TikTok URL. This is NOT available to customers in any public package, and access is approved on a case-by-case basis.
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody Config for the signature generation
         * @param {string} [preferredAgentIds] The preferred agent ID to use when signing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTikTokUrl: async (iSignTikTokUrlBody: ISignTikTokUrlBody, preferredAgentIds?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iSignTikTokUrlBody' is not null or undefined
            assertParamExists('signTikTokUrl', 'iSignTikTokUrlBody', iSignTikTokUrlBody)
            const localVarPath = `/tiktok/sign_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (preferredAgentIds !== undefined) {
                localVarQueryParameter['preferred_agent_ids'] = preferredAgentIds;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iSignTikTokUrlBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TikTokApi - functional programming interface
 * @export
 */
export const TikTokApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TikTokApiAxiosParamCreator(configuration)
    return {
        /**
         * Sign a non-LIVE TikTok URL. This is NOT available to customers in any public package, and access is approved on a case-by-case basis.
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody Config for the signature generation
         * @param {string} [preferredAgentIds] The preferred agent ID to use when signing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signTikTokUrl(iSignTikTokUrlBody: ISignTikTokUrlBody, preferredAgentIds?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ISignTikTokUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signTikTokUrl(iSignTikTokUrlBody, preferredAgentIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokApi.signTikTokUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TikTokApi - factory interface
 * @export
 */
export const TikTokApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TikTokApiFp(configuration)
    return {
        /**
         * Sign a non-LIVE TikTok URL. This is NOT available to customers in any public package, and access is approved on a case-by-case basis.
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody Config for the signature generation
         * @param {string} [preferredAgentIds] The preferred agent ID to use when signing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTikTokUrl(iSignTikTokUrlBody: ISignTikTokUrlBody, preferredAgentIds?: string, options?: RawAxiosRequestConfig): AxiosPromise<ISignTikTokUrlResponse> {
            return localVarFp.signTikTokUrl(iSignTikTokUrlBody, preferredAgentIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TikTokApi - object-oriented interface
 * @export
 * @class TikTokApi
 * @extends {BaseAPI}
 */
export class TikTokApi extends BaseAPI {
    /**
     * Sign a non-LIVE TikTok URL. This is NOT available to customers in any public package, and access is approved on a case-by-case basis.
     * @param {ISignTikTokUrlBody} iSignTikTokUrlBody Config for the signature generation
     * @param {string} [preferredAgentIds] The preferred agent ID to use when signing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokApi
     */
    public signTikTokUrl(iSignTikTokUrlBody: ISignTikTokUrlBody, preferredAgentIds?: string, options?: RawAxiosRequestConfig) {
        return TikTokApiFp(this.configuration).signTikTokUrl(iSignTikTokUrlBody, preferredAgentIds, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebcastApi - axios parameter creator
 * @export
 */
export const WebcastApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
         * @param {string} client The client ID
         * @param {string} [roomId] The room ID to fetch the webcast URL for
         * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
         * @param {string} [cursor] The cursor to fetch the webcast URL for
         * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
         * @param {string} [userAgent] Override the user agent used in the signature
         * @param {string} [preferredAgentIds] The preferred agent ID
         * @param {string} [ttTargetIdc] The target IDC to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL: async (client: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, preferredAgentIds?: string, ttTargetIdc?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'client' is not null or undefined
            assertParamExists('fetchWebcastURL', 'client', client)
            const localVarPath = `/webcast/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }

            if (uniqueId !== undefined) {
                localVarQueryParameter['unique_id'] = uniqueId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (userAgent !== undefined) {
                localVarQueryParameter['user_agent'] = userAgent;
            }

            if (preferredAgentIds !== undefined) {
                localVarQueryParameter['preferred_agent_ids'] = preferredAgentIds;
            }

            if (ttTargetIdc !== undefined) {
                localVarQueryParameter['tt_target_idc'] = ttTargetIdc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webcast/rate_limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch Room Id for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId: async (uniqueId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('retrieveRoomId', 'uniqueId', uniqueId)
            const localVarPath = `/webcast/room_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo: async (uniqueId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('retrieveRoomInfo', 'uniqueId', uniqueId)
            const localVarPath = `/webcast/room_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat: async (iWebcastRoomChatPayload: IWebcastRoomChatPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iWebcastRoomChatPayload' is not null or undefined
            assertParamExists('sendRoomChat', 'iWebcastRoomChatPayload', iWebcastRoomChatPayload)
            const localVarPath = `/webcast/chat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iWebcastRoomChatPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody 
         * @param {string} [preferredAgentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl: async (iSignTikTokUrlBody: ISignTikTokUrlBody, preferredAgentId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iSignTikTokUrlBody' is not null or undefined
            assertParamExists('signWebcastUrl', 'iSignTikTokUrlBody', iSignTikTokUrlBody)
            const localVarPath = `/webcast/sign_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (preferredAgentId !== undefined) {
                localVarQueryParameter['preferred_agent_id'] = preferredAgentId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iSignTikTokUrlBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebcastApi - functional programming interface
 * @export
 */
export const WebcastApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebcastApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
         * @param {string} client The client ID
         * @param {string} [roomId] The room ID to fetch the webcast URL for
         * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
         * @param {string} [cursor] The cursor to fetch the webcast URL for
         * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
         * @param {string} [userAgent] Override the user agent used in the signature
         * @param {string} [preferredAgentIds] The preferred agent ID
         * @param {string} [ttTargetIdc] The target IDC to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchWebcastURL(client: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, preferredAgentIds?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, preferredAgentIds, ttTargetIdc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebcastApi.fetchWebcastURL']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IGetRateLimits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebcastApi.getRateLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch Room Id for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IWebcastRoomIdRouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomId(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebcastApi.retrieveRoomId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IWebcastRoomInfoRouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomInfo(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebcastApi.retrieveRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRoomChat(iWebcastRoomChatPayload: IWebcastRoomChatPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IWebcastRoomChatRouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendRoomChat(iWebcastRoomChatPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebcastApi.sendRoomChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody 
         * @param {string} [preferredAgentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signWebcastUrl(iSignTikTokUrlBody: ISignTikTokUrlBody, preferredAgentId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignWebcastUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signWebcastUrl(iSignTikTokUrlBody, preferredAgentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebcastApi.signWebcastUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebcastApi - factory interface
 * @export
 */
export const WebcastApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebcastApiFp(configuration)
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
         * @param {string} client The client ID
         * @param {string} [roomId] The room ID to fetch the webcast URL for
         * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
         * @param {string} [cursor] The cursor to fetch the webcast URL for
         * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
         * @param {string} [userAgent] Override the user agent used in the signature
         * @param {string} [preferredAgentIds] The preferred agent ID
         * @param {string} [ttTargetIdc] The target IDC to use for the request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL(client: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, preferredAgentIds?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, preferredAgentIds, ttTargetIdc, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits(options?: RawAxiosRequestConfig): AxiosPromise<IGetRateLimits> {
            return localVarFp.getRateLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch Room Id for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<IWebcastRoomIdRouteResponse> {
            return localVarFp.retrieveRoomId(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<IWebcastRoomInfoRouteResponse> {
            return localVarFp.retrieveRoomInfo(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
         * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat(iWebcastRoomChatPayload: IWebcastRoomChatPayload, options?: RawAxiosRequestConfig): AxiosPromise<IWebcastRoomChatRouteResponse> {
            return localVarFp.sendRoomChat(iWebcastRoomChatPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ISignTikTokUrlBody} iSignTikTokUrlBody 
         * @param {string} [preferredAgentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl(iSignTikTokUrlBody: ISignTikTokUrlBody, preferredAgentId?: string, options?: RawAxiosRequestConfig): AxiosPromise<SignWebcastUrl200Response> {
            return localVarFp.signWebcastUrl(iSignTikTokUrlBody, preferredAgentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebcastApi - object-oriented interface
 * @export
 * @class WebcastApi
 * @extends {BaseAPI}
 */
export class WebcastApi extends BaseAPI {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room Id.
     * @param {string} client The client ID
     * @param {string} [roomId] The room ID to fetch the webcast URL for
     * @param {string} [uniqueId] The unique ID of the TikTok user. Only available to Enterprise users.
     * @param {string} [cursor] The cursor to fetch the webcast URL for
     * @param {string} [sessionId] The session ID used to fetch a privileged WS connection
     * @param {string} [userAgent] Override the user agent used in the signature
     * @param {string} [preferredAgentIds] The preferred agent ID
     * @param {string} [ttTargetIdc] The target IDC to use for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    public fetchWebcastURL(client: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, preferredAgentIds?: string, ttTargetIdc?: string, options?: RawAxiosRequestConfig) {
        return WebcastApiFp(this.configuration).fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, preferredAgentIds, ttTargetIdc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    public getRateLimits(options?: RawAxiosRequestConfig) {
        return WebcastApiFp(this.configuration).getRateLimits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch Room Id for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    public retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig) {
        return WebcastApiFp(this.configuration).retrieveRoomId(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch data for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    public retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig) {
        return WebcastApiFp(this.configuration).retrieveRoomInfo(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch Room Info for a given uniqueId. This is a premium endpoint that bypasses TikTok captchas. It is counted towards your request quota.
     * @param {IWebcastRoomChatPayload} iWebcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    public sendRoomChat(iWebcastRoomChatPayload: IWebcastRoomChatPayload, options?: RawAxiosRequestConfig) {
        return WebcastApiFp(this.configuration).sendRoomChat(iWebcastRoomChatPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ISignTikTokUrlBody} iSignTikTokUrlBody 
     * @param {string} [preferredAgentId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebcastApi
     */
    public signWebcastUrl(iSignTikTokUrlBody: ISignTikTokUrlBody, preferredAgentId?: string, options?: RawAxiosRequestConfig) {
        return WebcastApiFp(this.configuration).signWebcastUrl(iSignTikTokUrlBody, preferredAgentId, options).then((request) => request(this.axios, this.basePath));
    }
}



