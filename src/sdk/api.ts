/* tslint:disable */
/* eslint-disable */
/**
 * The Sign Serverâ„¢
 * Sign Server API Documentation
 *
 * The version of the OpenAPI document: dev
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'day': number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'hour': number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'minute': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'webhook_secret': string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'max_alerts': number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'max_websockets': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'expires_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface AccountConfig
 */
export interface AccountConfig {
    /**
     * 
     * @type {number}
     * @memberof AccountConfig
     */
    'day': number;
    /**
     * 
     * @type {number}
     * @memberof AccountConfig
     */
    'hour': number;
    /**
     * 
     * @type {number}
     * @memberof AccountConfig
     */
    'minute': number;
    /**
     * 
     * @type {string}
     * @memberof AccountConfig
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AccountConfig
     */
    'webhook_secret': string;
    /**
     * 
     * @type {number}
     * @memberof AccountConfig
     */
    'max_alerts': number;
    /**
     * 
     * @type {number}
     * @memberof AccountConfig
     */
    'max_websockets': number;
    /**
     * 
     * @type {string}
     * @memberof AccountConfig
     */
    'expires_at': string | null;
}
/**
 * 
 * @export
 * @enum {number}
 */

export const AccountScopes = {
    NUMBER_MINUS_1: -1,
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8
} as const;

export type AccountScopes = typeof AccountScopes[keyof typeof AccountScopes];


/**
 * 
 * @export
 * @interface AccountWithPermissionsSafe
 */
export interface AccountWithPermissionsSafe {
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'day': number;
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'hour': number;
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'minute': number;
    /**
     * 
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'webhook_secret': string;
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'max_alerts': number;
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'max_websockets': number;
    /**
     * 
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'expires_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof AccountWithPermissionsSafe
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof AccountWithPermissionsSafe
     */
    'id': number;
    /**
     * 
     * @type {Array<AccountScopes>}
     * @memberof AccountWithPermissionsSafe
     */
    'scopes': Array<AccountScopes>;
}
/**
 * 
 * @export
 * @interface AccountsTableRequestLimits
 */
export interface AccountsTableRequestLimits {
    /**
     * 
     * @type {number}
     * @memberof AccountsTableRequestLimits
     */
    'day': number;
    /**
     * 
     * @type {number}
     * @memberof AccountsTableRequestLimits
     */
    'hour': number;
    /**
     * 
     * @type {number}
     * @memberof AccountsTableRequestLimits
     */
    'minute': number;
}
/**
 * 
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'account_id': number;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'alert_creator_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof Alert
     */
    'read_only': boolean;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'alert_creator_nickname': string | null;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'alert_creator_avatar_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'alert_creator_username': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface AlertConfig
 */
export interface AlertConfig {
    /**
     * 
     * @type {number}
     * @memberof AlertConfig
     */
    'account_id': number;
    /**
     * 
     * @type {number}
     * @memberof AlertConfig
     */
    'alert_creator_id': number;
    /**
     * 
     * @type {boolean}
     * @memberof AlertConfig
     */
    'read_only': boolean;
}
/**
 * 
 * @export
 * @interface AlertTarget
 */
export interface AlertTarget {
    /**
     * 
     * @type {string}
     * @memberof AlertTarget
     */
    'url': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof AlertTarget
     */
    'metadata': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof AlertTarget
     */
    'alert_id': number;
    /**
     * 
     * @type {number}
     * @memberof AlertTarget
     */
    'alert_creator_id': number;
    /**
     * 
     * @type {AlertTargetStatus}
     * @memberof AlertTarget
     */
    'last_status': AlertTargetStatus;
    /**
     * 
     * @type {AlertTargetFormat}
     * @memberof AlertTarget
     */
    'format': AlertTargetFormat;
    /**
     * 
     * @type {number}
     * @memberof AlertTarget
     */
    'account_id': number;
    /**
     * 
     * @type {string}
     * @memberof AlertTarget
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof AlertTarget
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof AlertTarget
     */
    'id': number;
}


/**
 * 
 * @export
 * @interface AlertTargetConfig
 */
export interface AlertTargetConfig {
    /**
     * 
     * @type {string}
     * @memberof AlertTargetConfig
     */
    'url': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof AlertTargetConfig
     */
    'metadata': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof AlertTargetConfig
     */
    'alert_id': number;
    /**
     * 
     * @type {number}
     * @memberof AlertTargetConfig
     */
    'alert_creator_id': number;
    /**
     * 
     * @type {AlertTargetStatus}
     * @memberof AlertTargetConfig
     */
    'last_status': AlertTargetStatus;
    /**
     * 
     * @type {AlertTargetFormat}
     * @memberof AlertTargetConfig
     */
    'format': AlertTargetFormat;
}


/**
 * 
 * @export
 * @enum {number}
 */

export const AlertTargetFormat = {
    NUMBER_1: 1
} as const;

export type AlertTargetFormat = typeof AlertTargetFormat[keyof typeof AlertTargetFormat];


/**
 * 
 * @export
 * @enum {number}
 */

export const AlertTargetStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_4: 4
} as const;

export type AlertTargetStatus = typeof AlertTargetStatus[keyof typeof AlertTargetStatus];


/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof ApiKey
     */
    'account_id': number;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'created_at': string;
    /**
     * 
     * @type {number}
     * @memberof ApiKey
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ApiKeyConfig
 */
export interface ApiKeyConfig {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyConfig
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyConfig
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof ApiKeyConfig
     */
    'account_id': number;
}
/**
 * 
 * @export
 * @interface CountSignUsage
 */
export interface CountSignUsage {
    /**
     * 
     * @type {number}
     * @memberof CountSignUsage
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof CountSignUsage
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof CountSignUsage
     */
    'pages'?: number;
}
/**
 * Configuration for the alert
 * @export
 * @interface CreateAlertRequest
 */
export interface CreateAlertRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAlertRequest
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface CreateAlertResponse
 */
export interface CreateAlertResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateAlertResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof CreateAlertResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Alert}
     * @memberof CreateAlertResponse
     */
    'alert'?: Alert;
}
/**
 * 
 * @export
 * @interface CreateAlertTargetPayload
 */
export interface CreateAlertTargetPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateAlertTargetPayload
     */
    'url': string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof CreateAlertTargetPayload
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CreateAlertTargetResponse
 */
export interface CreateAlertTargetResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateAlertTargetResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof CreateAlertTargetResponse
     */
    'message'?: string;
    /**
     * 
     * @type {AlertTarget}
     * @memberof CreateAlertTargetResponse
     */
    'target'?: AlertTarget;
}
/**
 * 
 * @export
 * @interface CreateJWTResponse
 */
export interface CreateJWTResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateJWTResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof CreateJWTResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateJWTResponse
     */
    'token'?: string;
    /**
     * 
     * @type {JWTConfig}
     * @memberof CreateJWTResponse
     */
    'config'?: JWTConfig;
}
/**
 * 
 * @export
 * @interface CreateKeyPayload
 */
export interface CreateKeyPayload {
    /**
     * 
     * @type {string}
     * @memberof CreateKeyPayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateKeyResponse
 */
export interface CreateKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof CreateKeyResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ApiKey}
     * @memberof CreateKeyResponse
     */
    'key'?: ApiKey;
}
/**
 * 
 * @export
 * @interface DeleteAlertResponse
 */
export interface DeleteAlertResponse {
    /**
     * 
     * @type {number}
     * @memberof DeleteAlertResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteAlertResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteAlertTargetResponse
 */
export interface DeleteAlertTargetResponse {
    /**
     * 
     * @type {number}
     * @memberof DeleteAlertTargetResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteAlertTargetResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteKeyResponse
 */
export interface DeleteKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof DeleteKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteKeyResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetRateLimits
 */
export interface GetRateLimits {
    /**
     * 
     * @type {number}
     * @memberof GetRateLimits
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof GetRateLimits
     */
    'message'?: string;
    /**
     * 
     * @type {RateLimitInfo}
     * @memberof GetRateLimits
     */
    'day'?: RateLimitInfo;
    /**
     * 
     * @type {RateLimitInfo}
     * @memberof GetRateLimits
     */
    'hour'?: RateLimitInfo;
    /**
     * 
     * @type {RateLimitInfo}
     * @memberof GetRateLimits
     */
    'minute'?: RateLimitInfo;
    /**
     * 
     * @type {LoadShedInfo}
     * @memberof GetRateLimits
     */
    'load_shedding': LoadShedInfo;
}
/**
 * 
 * @export
 * @interface GetSignUsageResponse
 */
export interface GetSignUsageResponse {
    /**
     * 
     * @type {number}
     * @memberof GetSignUsageResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof GetSignUsageResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<SignLogPublic>}
     * @memberof GetSignUsageResponse
     */
    'usage'?: Array<SignLogPublic>;
}
/**
 * 
 * @export
 * @interface GetSignWebcastUrlResponse
 */
export interface GetSignWebcastUrlResponse {
    /**
     * 
     * @type {number}
     * @memberof GetSignWebcastUrlResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'signedUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'msToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'browserVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'browserName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    '_signature'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'X-Bogus'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignWebcastUrlResponse
     */
    'User-Agent'?: string;
}
/**
 * 
 * @export
 * @interface HostsResponse
 */
export interface HostsResponse {
    /**
     * 
     * @type {number}
     * @memberof HostsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof HostsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<PeerPresence>}
     * @memberof HostsResponse
     */
    'hosts'?: Array<PeerPresence>;
}
/**
 * 
 * @export
 * @interface JSONResponse
 */
export interface JSONResponse {
    /**
     * 
     * @type {number}
     * @memberof JSONResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof JSONResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface JWTConfig
 */
export interface JWTConfig {
    /**
     * 
     * @type {string}
     * @memberof JWTConfig
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof JWTConfig
     */
    'expiresAt': number;
    /**
     * 
     * @type {number}
     * @memberof JWTConfig
     */
    'ttl': number;
    /**
     * 
     * @type {number}
     * @memberof JWTConfig
     */
    'accountId': number;
    /**
     * 
     * @type {number}
     * @memberof JWTConfig
     */
    'apiKeyId': number;
    /**
     * 
     * @type {AccountsTableRequestLimits}
     * @memberof JWTConfig
     */
    'limits': AccountsTableRequestLimits;
    /**
     * 
     * @type {WebSocketJWTLimits}
     * @memberof JWTConfig
     */
    'webSocketData': WebSocketJWTLimits;
    /**
     * 
     * @type {string}
     * @memberof JWTConfig
     */
    'name': string | null;
}
/**
 * 
 * @export
 * @interface JWTCreateConfig
 */
export interface JWTCreateConfig {
    /**
     * 
     * @type {AccountsTableRequestLimits}
     * @memberof JWTCreateConfig
     */
    'limits'?: AccountsTableRequestLimits | null;
    /**
     * 
     * @type {WebSocketJWTLimits}
     * @memberof JWTCreateConfig
     */
    'websockets'?: WebSocketJWTLimits | null;
    /**
     * 
     * @type {number}
     * @memberof JWTCreateConfig
     */
    'expireAfter': number;
    /**
     * 
     * @type {string}
     * @memberof JWTCreateConfig
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ListAlertTargetsResponse
 */
export interface ListAlertTargetsResponse {
    /**
     * 
     * @type {number}
     * @memberof ListAlertTargetsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ListAlertTargetsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<AlertTarget>}
     * @memberof ListAlertTargetsResponse
     */
    'targets'?: Array<AlertTarget>;
}
/**
 * 
 * @export
 * @interface ListAlertsResponse
 */
export interface ListAlertsResponse {
    /**
     * 
     * @type {number}
     * @memberof ListAlertsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ListAlertsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof ListAlertsResponse
     */
    'alerts'?: Array<Alert>;
    /**
     * 
     * @type {boolean}
     * @memberof ListAlertsResponse
     */
    'hasMore': boolean;
}
/**
 * 
 * @export
 * @interface ListKeysResponse
 */
export interface ListKeysResponse {
    /**
     * 
     * @type {number}
     * @memberof ListKeysResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ListKeysResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof ListKeysResponse
     */
    'keys'?: Array<ApiKey>;
}
/**
 * 
 * @export
 * @interface LoadShedInfo
 */
export interface LoadShedInfo {
    /**
     * 
     * @type {number}
     * @memberof LoadShedInfo
     */
    'at': number;
    /**
     * 
     * @type {number}
     * @memberof LoadShedInfo
     */
    'chance': number;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
 */
export interface PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber {
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'sec_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'numeric_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'signature'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'is_verified'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'following'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartialAvatarUrlStringNicknameStringSecUidStringNumericUidStringSignatureStringIsVerifiedBooleanFollowingNumberFollowersNumber
     */
    'followers'?: number;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
 */
export interface PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray {
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'signedUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'userAgent'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'browserName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'browserVersion'?: string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'tokens'?: { [key: string]: string; };
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: string; }}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'requestHeaders'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray
     */
    'cookies'?: Array<{ [key: string]: string; }>;
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
 */
export interface PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString {
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'status'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'is_live'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'cover_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'start_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'current_viewers'?: number;
    /**
     * 
     * @type {number}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'total_viewers'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'hls_pull_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'flv_pull_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'hls_pull_url_ld'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString
     */
    'flv_pull_url_ld'?: string;
}
/**
 * 
 * @export
 * @interface PeerPresence
 */
export interface PeerPresence {
    /**
     * 
     * @type {number}
     * @memberof PeerPresence
     */
    'lastSeen': number;
    /**
     * 
     * @type {PeerRole}
     * @memberof PeerPresence
     */
    'role': PeerRole;
    /**
     * 
     * @type {string}
     * @memberof PeerPresence
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PeerPresence
     */
    'type': PeerPresenceTypeEnum;
}

export const PeerPresenceTypeEnum = {
    Api: 'api',
    Agent: 'agent'
} as const;

export type PeerPresenceTypeEnum = typeof PeerPresenceTypeEnum[keyof typeof PeerPresenceTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const PeerRole = {
    Public: 'public',
    Enterprise: 'enterprise',
    Staging: 'staging'
} as const;

export type PeerRole = typeof PeerRole[keyof typeof PeerRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const ProxyRegion = {
    De: 'DE',
    Es: 'ES',
    Fr: 'FR',
    Gb: 'GB',
    Pl: 'PL',
    Us: 'US'
} as const;

export type ProxyRegion = typeof ProxyRegion[keyof typeof ProxyRegion];


/**
 * 
 * @export
 * @interface RateLimitInfo
 */
export interface RateLimitInfo {
    /**
     * 
     * @type {number}
     * @memberof RateLimitInfo
     */
    'max': number;
    /**
     * 
     * @type {number}
     * @memberof RateLimitInfo
     */
    'remaining': number;
    /**
     * 
     * @type {string}
     * @memberof RateLimitInfo
     */
    'reset_at': string | null;
}
/**
 * 
 * @export
 * @interface RetrieveAccountResponse
 */
export interface RetrieveAccountResponse {
    /**
     * 
     * @type {number}
     * @memberof RetrieveAccountResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAccountResponse
     */
    'message'?: string;
    /**
     * 
     * @type {AccountWithPermissionsSafe}
     * @memberof RetrieveAccountResponse
     */
    'account'?: AccountWithPermissionsSafe;
}
/**
 * 
 * @export
 * @interface RetrieveAgentHostsResponse
 */
export interface RetrieveAgentHostsResponse {
    /**
     * 
     * @type {number}
     * @memberof RetrieveAgentHostsResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAgentHostsResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<PeerPresence>}
     * @memberof RetrieveAgentHostsResponse
     */
    'agents': Array<PeerPresence>;
}
/**
 * 
 * @export
 * @interface RetrieveAggregateUsageResponse
 */
export interface RetrieveAggregateUsageResponse {
    /**
     * 
     * @type {number}
     * @memberof RetrieveAggregateUsageResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAggregateUsageResponse
     */
    'message'?: string;
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: { [key: string]: any; }; }}
     * @memberof RetrieveAggregateUsageResponse
     */
    'usage'?: { [key: string]: { [key: string]: any; }; };
}
/**
 * 
 * @export
 * @interface RetrieveAlertResponse
 */
export interface RetrieveAlertResponse {
    /**
     * 
     * @type {number}
     * @memberof RetrieveAlertResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Alert}
     * @memberof RetrieveAlertResponse
     */
    'alert'?: Alert;
    /**
     * 
     * @type {RetrieveAlertResponseCreator}
     * @memberof RetrieveAlertResponse
     */
    'creator'?: RetrieveAlertResponseCreator;
}
/**
 * 
 * @export
 * @interface RetrieveAlertResponseCreator
 */
export interface RetrieveAlertResponseCreator {
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'last_nickname': string | null;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'last_avatar_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'room_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'state_label': string;
    /**
     * 
     * @type {number}
     * @memberof RetrieveAlertResponseCreator
     */
    'state': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveAlertResponseCreator
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface RetrieveKeyResponse
 */
export interface RetrieveKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof RetrieveKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof RetrieveKeyResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ApiKey}
     * @memberof RetrieveKeyResponse
     */
    'key'?: ApiKey;
}
/**
 * 
 * @export
 * @interface SignLogPublic
 */
export interface SignLogPublic {
    /**
     * 
     * @type {string}
     * @memberof SignLogPublic
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SignLogPublic
     */
    'ts': string;
    /**
     * 
     * @type {number}
     * @memberof SignLogPublic
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof SignLogPublic
     */
    'client': string;
    /**
     * 
     * @type {string}
     * @memberof SignLogPublic
     */
    'ip': string;
    /**
     * 
     * @type {number}
     * @memberof SignLogPublic
     */
    'api_key_id': number;
    /**
     * 
     * @type {string}
     * @memberof SignLogPublic
     */
    'user_agent': string;
    /**
     * 
     * @type {string}
     * @memberof SignLogPublic
     */
    'agent_id': string;
}
/**
 * 
 * @export
 * @interface SignTikTokUrlBody
 */
export interface SignTikTokUrlBody {
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'userAgent'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'method'?: SignTikTokUrlBodyMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'ttTargetIdc'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'payload'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlBody
     */
    'type'?: SignTikTokUrlBodyTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof SignTikTokUrlBody
     */
    'includeBrowserParams'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SignTikTokUrlBody
     */
    'includeVerifyFp'?: boolean;
}

export const SignTikTokUrlBodyMethodEnum = {
    Get: 'GET',
    Post: 'POST',
    Options: 'OPTIONS',
    Put: 'PUT',
    Delete: 'DELETE',
    Patch: 'PATCH',
    Head: 'HEAD'
} as const;

export type SignTikTokUrlBodyMethodEnum = typeof SignTikTokUrlBodyMethodEnum[keyof typeof SignTikTokUrlBodyMethodEnum];
export const SignTikTokUrlBodyTypeEnum = {
    Fetch: 'fetch',
    Xhr: 'xhr'
} as const;

export type SignTikTokUrlBodyTypeEnum = typeof SignTikTokUrlBodyTypeEnum[keyof typeof SignTikTokUrlBodyTypeEnum];

/**
 * 
 * @export
 * @interface SignTikTokUrlResponse
 */
export interface SignTikTokUrlResponse {
    /**
     * 
     * @type {number}
     * @memberof SignTikTokUrlResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof SignTikTokUrlResponse
     */
    'message'?: string;
    /**
     * 
     * @type {PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray}
     * @memberof SignTikTokUrlResponse
     */
    'response'?: PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray;
}
/**
 * 
 * @export
 * @interface SignWebcastUrl200Response
 */
export interface SignWebcastUrl200Response {
    /**
     * 
     * @type {number}
     * @memberof SignWebcastUrl200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof SignWebcastUrl200Response
     */
    'message'?: string;
    /**
     * 
     * @type {PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray}
     * @memberof SignWebcastUrl200Response
     */
    'response'?: PartialSignedUrlStringUserAgentStringBrowserNameStringBrowserVersionStringTokensRecordStringStringRequestHeadersRecordStringStringCookiesRecordStringStringArray;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StreamType = {
    HlsLd: 'hls_ld',
    HlsSd: 'hls_sd',
    FlvLd: 'flv_ld',
    FlvSd: 'flv_sd'
} as const;

export type StreamType = typeof StreamType[keyof typeof StreamType];


/**
 * 
 * @export
 * @interface TestAlertTargetResponse
 */
export interface TestAlertTargetResponse {
    /**
     * 
     * @type {number}
     * @memberof TestAlertTargetResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof TestAlertTargetResponse
     */
    'message'?: string;
    /**
     * 
     * @type {AlertTargetStatus}
     * @memberof TestAlertTargetResponse
     */
    'status'?: AlertTargetStatus;
    /**
     * 
     * @type {string}
     * @memberof TestAlertTargetResponse
     */
    'statusLabel'?: string;
}


/**
 * 
 * @export
 * @interface TikTokLiveUser
 */
export interface TikTokLiveUser {
    /**
     * Construct a type with a set of properties K of type T
     * @type {{ [key: string]: any; }}
     * @memberof TikTokLiveUser
     */
    'raw': { [key: string]: any; };
    /**
     * 
     * @type {PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString}
     * @memberof TikTokLiveUser
     */
    'room_info'?: PartialStatusNumberIsLiveBooleanIdStringCoverUrlStringTitleStringStartTimeNumberCurrentViewersNumberTotalViewersNumberHlsPullUrlStringFlvPullUrlStringHlsPullUrlLdStringFlvPullUrlLdString;
    /**
     * 
     * @type {TikTokLiveUserUser}
     * @memberof TikTokLiveUser
     */
    'user'?: TikTokLiveUserUser;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUser
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface TikTokLiveUserUser
 */
export interface TikTokLiveUserUser {
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'avatar_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'sec_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'numeric_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'signature'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TikTokLiveUserUser
     */
    'is_verified'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TikTokLiveUserUser
     */
    'following'?: number;
    /**
     * 
     * @type {number}
     * @memberof TikTokLiveUserUser
     */
    'followers'?: number;
    /**
     * 
     * @type {string}
     * @memberof TikTokLiveUserUser
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface UpdateKeyPayload
 */
export interface UpdateKeyPayload {
    /**
     * 
     * @type {string}
     * @memberof UpdateKeyPayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateKeyResponse
 */
export interface UpdateKeyResponse {
    /**
     * 
     * @type {number}
     * @memberof UpdateKeyResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateKeyResponse
     */
    'message'?: string;
    /**
     * 
     * @type {ApiKey}
     * @memberof UpdateKeyResponse
     */
    'config'?: ApiKey;
}
/**
 * 
 * @export
 * @interface WebSocketJWTLimits
 */
export interface WebSocketJWTLimits {
    /**
     * 
     * @type {Array<string>}
     * @memberof WebSocketJWTLimits
     */
    'allowedCreators': Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof WebSocketJWTLimits
     */
    'maxWebSockets': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WebcastFetchPlatform = {
    Mobile: 'mobile',
    Web: 'web'
} as const;

export type WebcastFetchPlatform = typeof WebcastFetchPlatform[keyof typeof WebcastFetchPlatform];


/**
 * 
 * @export
 * @interface WebcastRoomChatPayload
 */
export interface WebcastRoomChatPayload {
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomChatPayload
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomChatPayload
     */
    'sessionId': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomChatPayload
     */
    'ttTargetIdc': string;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomChatPayload
     */
    'roomId': string;
}
/**
 * 
 * @export
 * @interface WebcastRoomChatRouteResponse
 */
export interface WebcastRoomChatRouteResponse {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomChatRouteResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomChatRouteResponse
     */
    'message'?: string;
    /**
     * 
     * @type {any}
     * @memberof WebcastRoomChatRouteResponse
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface WebcastRoomIdRouteResponse
 */
export interface WebcastRoomIdRouteResponse {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomIdRouteResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomIdRouteResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomIdRouteResponse
     */
    'ok': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebcastRoomIdRouteResponse
     */
    'routes_attempted': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomIdRouteResponse
     */
    'is_live'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomIdRouteResponse
     */
    'room_id'?: string;
}
/**
 * 
 * @export
 * @interface WebcastRoomInfoRouteResponse
 */
export interface WebcastRoomInfoRouteResponse {
    /**
     * 
     * @type {number}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'ok': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'routes_attempted': Array<string>;
    /**
     * 
     * @type {TikTokLiveUser}
     * @memberof WebcastRoomInfoRouteResponse
     */
    'data': TikTokLiveUser | null;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage: async (accountId: number, from: string, to: string, apiKeyId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('countSignUsage', 'accountId', accountId)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('countSignUsage', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('countSignUsage', 'to', to)
            const localVarPath = `/accounts/{account_id}/usage/sign_usage/page_count`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (apiKeyId !== undefined) {
                localVarQueryParameter['api_key_id'] = apiKeyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage: async (accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getSignUsage', 'accountId', accountId)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getSignUsage', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getSignUsage', 'to', to)
            const localVarPath = `/accounts/{account_id}/usage/sign_usage`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (apiKeyId !== undefined) {
                localVarQueryParameter['api_key_id'] = apiKeyId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountSelf: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage: async (accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('retrieveAggregateUsage', 'accountId', accountId)
            // verify required parameter 'period' is not null or undefined
            assertParamExists('retrieveAggregateUsage', 'period', period)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('retrieveAggregateUsage', 'value', value)
            const localVarPath = `/accounts/{account_id}/usage/sign_usage/aggregate`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountSignUsage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countSignUsage(accountId, from, to, apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.countSignUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignUsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignUsage(accountId, from, to, apiKeyId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getSignUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAccountSelf(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAccountSelf(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.retrieveAccountSelf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAggregateUsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAggregateUsage(accountId, period, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.retrieveAggregateUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig): AxiosPromise<CountSignUsage> {
            return localVarFp.countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetSignUsageResponse> {
            return localVarFp.getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountSelf(options?: RawAxiosRequestConfig): AxiosPromise<RetrieveAccountResponse> {
            return localVarFp.retrieveAccountSelf(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig): AxiosPromise<RetrieveAggregateUsageResponse> {
            return localVarFp.retrieveAggregateUsage(accountId, period, value, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public countSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {string} from Start date for the logs
     * @param {string} to End date for the logs
     * @param {number} [apiKeyId] Optional API key ID to filter logs by
     * @param {number} [page] Page number to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getSignUsage(accountId: number, from: string, to: string, apiKeyId?: number, page?: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an account from the Sign API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public retrieveAccountSelf(options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).retrieveAccountSelf(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the usage logs for a specific account
     * @param {number} accountId Account ID to retrieve usage logs for
     * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
     * @param {number} value The value for the period (either hours or numbers)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public retrieveAggregateUsage(accountId: number, period: RetrieveAggregateUsagePeriodEnum, value: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).retrieveAggregateUsage(accountId, period, value, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RetrieveAggregateUsagePeriodEnum = {
    Hour: 'hour',
    Day: 'day'
} as const;
export type RetrieveAggregateUsagePeriodEnum = typeof RetrieveAggregateUsagePeriodEnum[keyof typeof RetrieveAggregateUsagePeriodEnum];


/**
 * AlertTargetsApi - axios parameter creator
 * @export
 */
export const AlertTargetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget: async (accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createAlertTarget', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('createAlertTarget', 'alertId', alertId)
            // verify required parameter 'createAlertTargetPayload' is not null or undefined
            assertParamExists('createAlertTarget', 'createAlertTargetPayload', createAlertTargetPayload)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlertTargetPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget: async (accountId: number, alertId: number, targetId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAlertTarget', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('deleteAlertTarget', 'alertId', alertId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('deleteAlertTarget', 'targetId', targetId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets: async (accountId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAlertTargets', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('listAlertTargets', 'alertId', alertId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget: async (accountId: number, alertId: number, targetId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('testAlertTarget', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('testAlertTarget', 'alertId', alertId)
            // verify required parameter 'targetId' is not null or undefined
            assertParamExists('testAlertTarget', 'targetId', targetId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/test`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)))
                .replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertTargetsApi - functional programming interface
 * @export
 */
export const AlertTargetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertTargetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlertTarget(accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAlertTargetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertTarget(accountId, alertId, createAlertTargetPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertTargetsApi.createAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAlertTargetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertTargetsApi.deleteAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAlertTargetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertTargets(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertTargetsApi.listAlertTargets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestAlertTargetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testAlertTarget(accountId, alertId, targetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertTargetsApi.testAlertTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlertTargetsApi - factory interface
 * @export
 */
export const AlertTargetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertTargetsApiFp(configuration)
    return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget(accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateAlertTargetResponse> {
            return localVarFp.createAlertTarget(accountId, alertId, createAlertTargetPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAlertTargetResponse> {
            return localVarFp.deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListAlertTargetsResponse> {
            return localVarFp.listAlertTargets(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig): AxiosPromise<TestAlertTargetResponse> {
            return localVarFp.testAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertTargetsApi - object-oriented interface
 * @export
 * @class AlertTargetsApi
 * @extends {BaseAPI}
 */
export class AlertTargetsApi extends BaseAPI {
    /**
     * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
     * @param {number} accountId The ID of the account to create the alert target for
     * @param {number} alertId The ID of the alert to create the target for
     * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    public createAlertTarget(accountId: number, alertId: number, createAlertTargetPayload: CreateAlertTargetPayload, options?: RawAxiosRequestConfig) {
        return AlertTargetsApiFp(this.configuration).createAlertTarget(accountId, alertId, createAlertTargetPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an alert target from the Sign API
     * @param {number} accountId The ID of the account to delete the alert target from
     * @param {number} alertId The ID of the alert to delete the target from
     * @param {number} targetId The ID of the target to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    public deleteAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig) {
        return AlertTargetsApiFp(this.configuration).deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all alert targets for a specific alert
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert to list targets for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    public listAlertTargets(accountId: number, alertId: number, options?: RawAxiosRequestConfig) {
        return AlertTargetsApiFp(this.configuration).listAlertTargets(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test an alert target
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The alert that the target belongs to
     * @param {number} targetId The target to test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertTargetsApi
     */
    public testAlertTarget(accountId: number, alertId: number, targetId: number, options?: RawAxiosRequestConfig) {
        return AlertTargetsApiFp(this.configuration).testAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert: async (accountId: number, createAlertRequest: CreateAlertRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createAlert', 'accountId', accountId)
            // verify required parameter 'createAlertRequest' is not null or undefined
            assertParamExists('createAlert', 'createAlertRequest', createAlertRequest)
            const localVarPath = `/accounts/{account_id}/alerts/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAlertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert: async (accountId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAlert', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('deleteAlert', 'alertId', alertId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts: async (accountId: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listAlerts', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/alerts/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert: async (accountId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('retrieveAlert', 'accountId', accountId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('retrieveAlert', 'alertId', alertId)
            const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlert(accountId: number, createAlertRequest: CreateAlertRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlert(accountId, createAlertRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.createAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.deleteAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlerts(accountId: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAlertsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAlerts(accountId, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.listAlerts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAlert(accountId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.retrieveAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(accountId: number, createAlertRequest: CreateAlertRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAlertResponse> {
            return localVarFp.createAlert(accountId, createAlertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAlertResponse> {
            return localVarFp.deleteAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(accountId: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListAlertsResponse> {
            return localVarFp.listAlerts(accountId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<RetrieveAlertResponse> {
            return localVarFp.retrieveAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     * Create a creator alert. These Alerts are used to notify users of a new livestream.
     * @param {number} accountId The ID of the account to create the alert for
     * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public createAlert(accountId: number, createAlertRequest: CreateAlertRequest, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).createAlert(accountId, createAlertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an alert from the Sign API
     * @param {number} accountId The ID of the account to delete the alert from
     * @param {number} alertId The ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public deleteAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).deleteAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public listAlerts(accountId: number, page?: number, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).listAlerts(accountId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific alert by its ID
     * @param {number} accountId The account that the alert belongs to
     * @param {number} alertId The ID of the alert to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public retrieveAlert(accountId: number, alertId: number, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).retrieveAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/analytics/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAgents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveAgentHostsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAgents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.fetchAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHosts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHosts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getHosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents(options?: RawAxiosRequestConfig): AxiosPromise<RetrieveAgentHostsResponse> {
            return localVarFp.fetchAgents(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts(options?: RawAxiosRequestConfig): AxiosPromise<HostsResponse> {
            return localVarFp.getHosts(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Retrieve the currently connected agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public fetchAgents(options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).fetchAgents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the list of API hosts (used for horizontal scaling)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getHosts(options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getHosts(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT: async (accountId: number, jWTCreateConfig: JWTCreateConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createJWT', 'accountId', accountId)
            // verify required parameter 'jWTCreateConfig' is not null or undefined
            assertParamExists('createJWT', 'jWTCreateConfig', jWTCreateConfig)
            const localVarPath = `/accounts/{account_id}/jwt/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jWTCreateConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (accountId: number, createKeyPayload: CreateKeyPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('createKey', 'accountId', accountId)
            // verify required parameter 'createKeyPayload' is not null or undefined
            assertParamExists('createKey', 'createKeyPayload', createKeyPayload)
            const localVarPath = `/accounts/{account_id}/api_keys/create`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createKeyPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteKey', 'accountId', accountId)
            // verify required parameter 'deleteBy' is not null or undefined
            assertParamExists('deleteKey', 'deleteBy', deleteBy)
            // verify required parameter 'deleteParam' is not null or undefined
            assertParamExists('deleteKey', 'deleteParam', deleteParam)
            const localVarPath = `/accounts/{account_id}/api_keys/delete`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (deleteBy !== undefined) {
                localVarQueryParameter['delete_by'] = deleteBy;
            }

            if (deleteParam !== undefined) {
                localVarQueryParameter['delete_param'] = deleteParam;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey: async (accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getKey', 'accountId', accountId)
            // verify required parameter 'retrieveParam' is not null or undefined
            assertParamExists('getKey', 'retrieveParam', retrieveParam)
            const localVarPath = `/accounts/{account_id}/api_keys/retrieve`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (retrieveBy !== undefined) {
                localVarQueryParameter['retrieve_by'] = retrieveBy;
            }

            if (retrieveParam !== undefined) {
                localVarQueryParameter['retrieve_param'] = retrieveParam;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listKeys', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/api_keys/list`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey: async (accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateKey', 'accountId', accountId)
            // verify required parameter 'updateBy' is not null or undefined
            assertParamExists('updateKey', 'updateBy', updateBy)
            // verify required parameter 'updateParam' is not null or undefined
            assertParamExists('updateKey', 'updateParam', updateParam)
            // verify required parameter 'updateKeyPayload' is not null or undefined
            assertParamExists('updateKey', 'updateKeyPayload', updateKeyPayload)
            const localVarPath = `/accounts/{account_id}/api_keys/update`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (updateBy !== undefined) {
                localVarQueryParameter['update_by'] = updateBy;
            }

            if (updateParam !== undefined) {
                localVarQueryParameter['update_param'] = updateParam;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateKeyPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateJWTResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJWT(accountId, jWTCreateConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.createJWT']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(accountId: number, createKeyPayload: CreateKeyPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(accountId, createKeyPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.createKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(accountId, deleteBy, deleteParam, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.deleteKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(accountId, retrieveParam, retrieveBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeys(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListKeysResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeys(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.listKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKey(accountId, updateBy, updateParam, updateKeyPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.updateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig): AxiosPromise<CreateJWTResponse> {
            return localVarFp.createJWT(accountId, jWTCreateConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(accountId: number, createKeyPayload: CreateKeyPayload, options?: RawAxiosRequestConfig): AxiosPromise<CreateKeyResponse> {
            return localVarFp.createKey(accountId, createKeyPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteKeyResponse> {
            return localVarFp.deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig): AxiosPromise<RetrieveKeyResponse> {
            return localVarFp.getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListKeysResponse> {
            return localVarFp.listKeys(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options?: RawAxiosRequestConfig): AxiosPromise<UpdateKeyResponse> {
            return localVarFp.updateKey(accountId, updateBy, updateParam, updateKeyPayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
     * @param {number} accountId The ID of the account to create the JWT for
     * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public createJWT(accountId: number, jWTCreateConfig: JWTCreateConfig, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).createJWT(accountId, jWTCreateConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new API key
     * @param {number} accountId The ID of the account to create the key for
     * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public createKey(accountId: number, createKeyPayload: CreateKeyPayload, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).createKey(accountId, createKeyPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to delete the key for
     * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
     * @param {string} deleteParam The API key field value to delete by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public deleteKey(accountId: number, deleteBy: DeleteKeyDeleteByEnum, deleteParam: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {string} retrieveParam The API key field value to retrieve by
     * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getKey(accountId: number, retrieveParam: string, retrieveBy?: GetKeyRetrieveByEnum, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an API key by its key value, name, or ID
     * @param {number} accountId The ID of the account to retrieve the key for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public listKeys(accountId: number, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).listKeys(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing API key
     * @param {number} accountId The account to update the key for
     * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
     * @param {string} updateParam The API key field value to update by
     * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public updateKey(accountId: number, updateBy: UpdateKeyUpdateByEnum, updateParam: string, updateKeyPayload: UpdateKeyPayload, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).updateKey(accountId, updateBy, updateParam, updateKeyPayload, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteKeyDeleteByEnum = {
    Value: 'value',
    Id: 'id'
} as const;
export type DeleteKeyDeleteByEnum = typeof DeleteKeyDeleteByEnum[keyof typeof DeleteKeyDeleteByEnum];
/**
 * @export
 */
export const GetKeyRetrieveByEnum = {
    Value: 'value',
    Id: 'id'
} as const;
export type GetKeyRetrieveByEnum = typeof GetKeyRetrieveByEnum[keyof typeof GetKeyRetrieveByEnum];
/**
 * @export
 */
export const UpdateKeyUpdateByEnum = {
    Value: 'value',
    Id: 'id'
} as const;
export type UpdateKeyUpdateByEnum = typeof UpdateKeyUpdateByEnum[keyof typeof UpdateKeyUpdateByEnum];


/**
 * TikTokLIVEApi - axios parameter creator
 * @export
 */
export const TikTokLIVEApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {ProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL: async (client?: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, country?: ProxyRegion, platform?: WebcastFetchPlatform, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webcast/fetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }

            if (roomId !== undefined) {
                localVarQueryParameter['room_id'] = roomId;
            }

            if (uniqueId !== undefined) {
                localVarQueryParameter['unique_id'] = uniqueId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (userAgent !== undefined) {
                localVarQueryParameter['user_agent'] = userAgent;
            }

            if (ttTargetIdc !== undefined) {
                localVarQueryParameter['tt_target_idc'] = ttTargetIdc;
            }

            if (clientEnter !== undefined) {
                localVarQueryParameter['client_enter'] = clientEnter;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webcast/rate_limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomCover: async (uniqueId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('retrieveRoomCover', 'uniqueId', uniqueId)
            const localVarPath = `/webcast/room_cover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId: async (uniqueId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('retrieveRoomId', 'uniqueId', uniqueId)
            const localVarPath = `/webcast/room_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo: async (uniqueId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('retrieveRoomInfo', 'uniqueId', uniqueId)
            const localVarPath = `/webcast/room_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomVideo: async (uniqueId: string, streamType?: StreamType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('retrieveRoomVideo', 'uniqueId', uniqueId)
            const localVarPath = `/webcast/room_video`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication jwt_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-jwt-key", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }

            if (streamType !== undefined) {
                localVarQueryParameter['streamType'] = streamType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat: async (webcastRoomChatPayload: WebcastRoomChatPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webcastRoomChatPayload' is not null or undefined
            assertParamExists('sendRoomChat', 'webcastRoomChatPayload', webcastRoomChatPayload)
            const localVarPath = `/webcast/chat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webcastRoomChatPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignTikTokUrlBody} signTikTokUrlBody 
         * @param {string} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl: async (signTikTokUrlBody: SignTikTokUrlBody, client?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signTikTokUrlBody' is not null or undefined
            assertParamExists('signWebcastUrl', 'signTikTokUrlBody', signTikTokUrlBody)
            const localVarPath = `/webcast/sign_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "apiKey", configuration)

            // authentication api_key_header required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signTikTokUrlBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TikTokLIVEApi - functional programming interface
 * @export
 */
export const TikTokLIVEApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TikTokLIVEApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {ProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchWebcastURL(client?: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, country?: ProxyRegion, platform?: WebcastFetchPlatform, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.fetchWebcastURL']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRateLimits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.getRateLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JSONResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomCover(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.retrieveRoomCover']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastRoomIdRouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomId(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.retrieveRoomId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastRoomInfoRouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomInfo(uniqueId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.retrieveRoomInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JSONResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomVideo(uniqueId, streamType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.retrieveRoomVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRoomChat(webcastRoomChatPayload: WebcastRoomChatPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebcastRoomChatRouteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendRoomChat(webcastRoomChatPayload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.sendRoomChat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignTikTokUrlBody} signTikTokUrlBody 
         * @param {string} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signWebcastUrl(signTikTokUrlBody: SignTikTokUrlBody, client?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignWebcastUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signWebcastUrl(signTikTokUrlBody, client, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TikTokLIVEApi.signWebcastUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TikTokLIVEApi - factory interface
 * @export
 */
export const TikTokLIVEApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TikTokLIVEApiFp(configuration)
    return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {ProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL(client?: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, country?: ProxyRegion, platform?: WebcastFetchPlatform, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits(options?: RawAxiosRequestConfig): AxiosPromise<GetRateLimits> {
            return localVarFp.getRateLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<JSONResponse> {
            return localVarFp.retrieveRoomCover(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebcastRoomIdRouteResponse> {
            return localVarFp.retrieveRoomId(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebcastRoomInfoRouteResponse> {
            return localVarFp.retrieveRoomInfo(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig): AxiosPromise<JSONResponse> {
            return localVarFp.retrieveRoomVideo(uniqueId, streamType, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat(webcastRoomChatPayload: WebcastRoomChatPayload, options?: RawAxiosRequestConfig): AxiosPromise<WebcastRoomChatRouteResponse> {
            return localVarFp.sendRoomChat(webcastRoomChatPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignTikTokUrlBody} signTikTokUrlBody 
         * @param {string} [client] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl(signTikTokUrlBody: SignTikTokUrlBody, client?: string, options?: RawAxiosRequestConfig): AxiosPromise<SignWebcastUrl200Response> {
            return localVarFp.signWebcastUrl(signTikTokUrlBody, client, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TikTokLIVEApi - object-oriented interface
 * @export
 * @class TikTokLIVEApi
 * @extends {BaseAPI}
 */
export class TikTokLIVEApi extends BaseAPI {
    /**
     * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
     * @param {string} [client] The client library identifier. Used for metrics.
     * @param {string} [roomId] The room ID to fetch the Webcast URL for.
     * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
     * @param {string} [cursor] Starting cursor for the webcast connection, if any
     * @param {string} [sessionId] Cookie - The account session ID from TikTok web
     * @param {string} [userAgent] Override the user agent used for signing and fetching
     * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
     * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
     * @param {ProxyRegion} [country] Country code to make the request from.
     * @param {WebcastFetchPlatform} [platform] Platform to connect with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public fetchWebcastURL(client?: string, roomId?: string, uniqueId?: string, cursor?: string, sessionId?: string, userAgent?: string, ttTargetIdc?: string, clientEnter?: boolean, country?: ProxyRegion, platform?: WebcastFetchPlatform, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public getRateLimits(options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).getRateLimits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public retrieveRoomCover(uniqueId: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).retrieveRoomCover(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch Room ID for a given uniqueId & whether that user is live.
     * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public retrieveRoomId(uniqueId: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).retrieveRoomId(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve TikTok Live Room Information
     * @param {string} uniqueId The unique identifier for the TikTok user or room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public retrieveRoomInfo(uniqueId: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).retrieveRoomInfo(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch TikTok LIVE Stream video given a uniqueId.
     * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
     * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public retrieveRoomVideo(uniqueId: string, streamType?: StreamType, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).retrieveRoomVideo(uniqueId, streamType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a chat to a TikTok LIVE room.
     * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public sendRoomChat(webcastRoomChatPayload: WebcastRoomChatPayload, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).sendRoomChat(webcastRoomChatPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignTikTokUrlBody} signTikTokUrlBody 
     * @param {string} [client] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TikTokLIVEApi
     */
    public signWebcastUrl(signTikTokUrlBody: SignTikTokUrlBody, client?: string, options?: RawAxiosRequestConfig) {
        return TikTokLIVEApiFp(this.configuration).signWebcastUrl(signTikTokUrlBody, client, options).then((request) => request(this.axios, this.basePath));
    }
}



